---
title: 分库分表
date: 2024-01-08 23:39:35
tags: 数据库
---

# 分库分表

开发项目的一开始，通常先用一张数据表，而一般来说数据库的容量是在2kw后面（具体看项目情况），因为mysql底层B+树结构增高，数据一个页无法装下，分散道多个页上，磁盘IO增加导致性能下降，于是就需要考虑分库分表。

## 垂直分表

这个原理很简单，就是把一张表中的某几个列拆成一个新表，这样单行数据就会变小，B+树里的单个数据页（固定16kb）内能放入的行数就会变多，从而使单表能放入更多的数据。

## 水平分表

水平分表有好几种做法，但不管是哪种，本质上都是将原来的 `user` 表，变成 `user_0, user1, user2 .... uerN`这样的N多张小表。

### id取模分表

假如我有两个`user`表，我把 `id % 2 = 0`的数据放在user_0表上， `id % 2 = 1` 的数据放在user_1表上

**优点：**

- 简单
- 读写数据很均匀分摊到每个分表上

缺点：

- 想要扩展表的话，则会产生数据对不上的问题，需要考虑**数据迁移**问题。

### id范围分表

根据id范围进行分表，例如[1- 2kw]的数据写在表0，[2kw - 4kw]写在表1，但这个存在问题，因为id是递增的，那新写入的数据一般都在**同一张表**上，如果业务场景写数据特别频繁，会出现**写热点**问题

**解决方法**： 将id设置成随机，或者参考下个方法

### id取模分表和id范围分表

我们可以在某个id范围里，引入取模的功能。比如 以前 1~2kw是user0表，现在可以在这个范围再分成5个表，也就是引入user0-0, user0-1到user1-4，在这5个表里取模。

举个例子，id=1kw，根据范围，会分到user1表，然后再进行取模 1kw % 5 = 0，也就是读写user0-0表。

这样就可以将写单表分摊为写多表。

这在分库的场景下优势会更明显，不同的库，可以把服务部署到不同的机器上，这样各个机器的性能都能被用起来。

![](分表.png)

### 添加中间件

对于业务代码来说，它只知道自己在读写一张 user 表，根本不知道底下还分了那么多张小表。

对于数据库来说，它并不知道自己被分表了，它只知道有那么几张表，正好名字长得比较像而已。

这还只是在一个数据库里做分表，如果范围再搞大点，还能在多个数据库里做分表，这就是所谓的分库分表。

不管是单库分表还是分库分表，都可以通过这样一个中间层逻辑做路由。

#### 框架

分库分表常用的框架有两个，`MyCat` 以及 `Apache ShardingSphere` 生态框架。

从使用角度上来说，分为 JDBC 驱动增强和数据库代理：

- **JDBC 驱动增强**：在 Java 的 JDBC 层进行扩展服务，**使用客户端直连数据库，无需额外部署服务和依赖**。可以理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。
- **数据库代理**：透明化的数据库代理端，通过实现数据库二进制协议，对异构语言提供支持。 **透明化数据库操作，对 DBA 更加友好**。

`Apache ShardingSphere` 有两款产品，分别是 `ShardingSphere-JDBC` 和 `ShardingSphere-Proxy` 两款产品，分别对应上述两种使用方式。`MyCat` 对应第二种方式。

两种方式各有利弊，分别是：

- **JDBC 驱动增强**： 

- - 优点：性能较高，通过 JDBC 直接向 MySQL 发起请求调用。
  - 优点：使用较为简单，理论上无需修改代码，仅需使用 `Apache ShardingSphere` 的配置即可。
  - 缺点：需要修改项目配置以及引入 Jar 包。
  - 缺点：对应用的内存有一定影响。

- **数据库代理**： 

- - 优点：无需对现有项目做任何配置或代码变更，将数据库的地址改为 Proxy 的地址即可。
  - 优点：Proxy 对 Java 应用内存没有任何影响。
  - 优点：分片后无法知道一条数据记录到底在那张表，Proxy 是屏蔽了分片逻辑，可直接操作逻辑表。
  - 缺点：JDBC 操作 MySQL 是点对点的，但是 Proxy 多了一层链路。

#### 如何选择分库分表框架？

分库分表策略

**Mycat**：MyCat 主要支持水平分表和垂直分库，提供相对基础的分片策略。

**ShardingSphere**：ShardingSphere 提供了更为灵活和丰富的分库分表策略，支持广泛的分片规则，包括范围、哈希、复合分片等。

支持的数据库

**Mycat**：主要支持 MySQL 数据库。

**ShardingSphere**：支持多种数据库，包括 MySQL、PostgreSQL、SQL Server 等。

功能扩展

**Mycat**：MyCat 在某些场景下可能表现出色，但在某些高并发和大数据量场景下性能可能有限。

**ShardingSphere**： ShardingSphere 在性能方面也表现良好，有一些优化策略，但性能表现也会受到具体配置和使用方式的影响。

推荐使用ShardingSphere

## 读扩散问题

上面提到的好几种分表方式，都用了id这一列作为分表的依据，这就是所谓的**分片键**。

实际上我们一般也是用的**数据库主键**作为**分片键**。

这样，理想情况下我们已知一个id，不管是根据哪种规则，我们都能很快定位到该读哪个分表。

但很多情况下，我们的查询又不是只查主键，如果我的数据库表有一列name，并且加了个普通索引。

```sql
select * from user where name = "小白";
```

由于name并不是分片键，我们没法定位到具体要到哪个分表上去执行sql。于是就会对所有分表都执行上面的sql，当然不会是串行执行sql，一般都是并发执行sql的。

如果我有100张表，就执行100次sql。

如果我有200张表，就执行200次sql。

随着我的表越来越多，次数会越来越多，这就是所谓的**读扩散问题**。
![](读扩散.png)

**这个问题的核心在于，主键是分片键，而普通索引并不分片**

我们需要单独创建个新的**中间表**，这个新表里的列就只有旧表的**主键id**和**普通索引列**，而这次换普通索引列来做分片键。

![](分片键.png)

当我们要查询**普通索引列**时，先到这个新的**中间表**里做一次查询，就能迅速定位到对应的主键id，然后再拿主键id去**实际查询表**里查一次数据。这样就从原来漫无目的的全表扩散查询，缩减为只查固定几个表了。

